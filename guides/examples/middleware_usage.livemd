# Signal Bus Middleware Usage

This guide demonstrates how to use the Signal Bus middleware system to extend and customize signal processing behavior.

## Overview

The middleware system allows you to:
- Log signal activity
- Transform signals before dispatch
- Filter or halt signal processing
- Add custom metadata
- Perform side effects

## Basic Usage

```elixir
# Start a bus with middleware
{:ok, _pid} = Jido.Signal.Bus.start_link([
  name: :my_bus,
  middleware: [
    {Jido.Signal.Bus.Middleware.Logger, level: :info, include_signal_data: true}
  ]
])

# Create and publish a signal
{:ok, signal} = Jido.Signal.new(%{
  type: "user.created",
  source: "/users",
  data: %{user_id: 123, email: "user@example.com"}
})

# Subscribe to signals
{:ok, subscription_id} = Jido.Signal.Bus.subscribe(:my_bus, "user.*")

# Publish the signal - middleware will automatically log it
{:ok, _} = Jido.Signal.Bus.publish(:my_bus, [signal])
```

## Creating Custom Middleware

```elixir
defmodule MyApp.AuditMiddleware do
  @moduledoc "Logs all signals to an audit system"
  
  use Jido.Signal.Bus.Middleware

  @impl true
  def init(opts) do
    audit_table = Keyword.get(opts, :audit_table, :signal_audit)
    {:ok, %{audit_table: audit_table}}
  end

  @impl true
  def before_publish(signals, context, state) do
    # Log each signal to audit table
    Enum.each(signals, fn signal ->
      :ets.insert(state.audit_table, {
        signal.id,
        signal.type,
        context.timestamp,
        signal.data
      })
    end)
    
    {:cont, signals, state}
  end

  @impl true
  def after_dispatch(signal, subscriber, result, context, state) do
    # Log dispatch results
    :ets.insert(state.audit_table, {
      "dispatch_#{signal.id}",
      subscriber.path,
      context.timestamp,
      result
    })
    
    {:cont, state}
  end
end
```

## Signal Transformation

```elixir
defmodule MyApp.EnrichmentMiddleware do
  @moduledoc "Adds enrichment data to signals"
  
  use Jido.Signal.Bus.Middleware

  @impl true
  def init(_opts) do
    {:ok, %{}}
  end

  @impl true
  def before_dispatch(signal, subscriber, _context, state) do
    # Add subscriber information to signal data
    enriched_data = Map.merge(signal.data || %{}, %{
      dispatched_to: subscriber.path,
      enriched_at: DateTime.utc_now()
    })
    
    enriched_signal = %{signal | data: enriched_data}
    {:cont, enriched_signal, state}
  end
end
```

## Filtering and Halting

```elixir
defmodule MyApp.FilterMiddleware do
  @moduledoc "Filters signals based on custom rules"
  
  use Jido.Signal.Bus.Middleware

  @impl true
  def init(opts) do
    blocked_types = Keyword.get(opts, :blocked_types, [])
    {:ok, %{blocked_types: blocked_types}}
  end

  @impl true
  def before_publish(signals, _context, state) do
    # Filter out blocked signal types
    allowed_signals = Enum.reject(signals, fn signal ->
      signal.type in state.blocked_types
    end)
    
    {:cont, allowed_signals, state}
  end

  @impl true
  def before_dispatch(signal, subscriber, _context, state) do
    # Skip dispatch to certain subscribers for sensitive signals
    if signal.type == "user.deleted" and subscriber.path =~ ~r/external/ do
      {:skip, state}
    else
      {:cont, signal, state}
    end
  end
end
```

## Multiple Middleware Configuration

```elixir
middleware = [
  # Audit all signal activity
  {MyApp.AuditMiddleware, audit_table: :my_audit},
  
  # Filter blocked content
  {MyApp.FilterMiddleware, blocked_types: ["spam.detected", "test.internal"]},
  
  # Add enrichment data
  {MyApp.EnrichmentMiddleware, []},
  
  # Log everything (should be last for complete logging)
  {Jido.Signal.Bus.Middleware.Logger, [
    level: :info,
    include_signal_data: true,
    log_errors: true
  ]}
]

{:ok, _pid} = Jido.Signal.Bus.start_link([
  name: :production_bus,
  middleware: middleware
])
```

## Error Handling

Middleware can also handle and react to dispatch errors:

```elixir
defmodule MyApp.RetryMiddleware do
  use Jido.Signal.Bus.Middleware

  @impl true
  def init(opts) do
    max_retries = Keyword.get(opts, :max_retries, 3)
    {:ok, %{max_retries: max_retries, retry_counts: %{}}}
  end

  @impl true
  def after_dispatch(signal, subscriber, {:error, reason}, _context, state) do
    retry_key = {signal.id, subscriber.path}
    current_retries = Map.get(state.retry_counts, retry_key, 0)
    
    if current_retries < state.max_retries do
      # Schedule retry (implementation would depend on your retry strategy)
      schedule_retry(signal, subscriber, reason)
      
      new_retry_counts = Map.put(state.retry_counts, retry_key, current_retries + 1)
      {:cont, %{state | retry_counts: new_retry_counts}}
    else
      # Max retries reached, log failure
      Logger.error("Signal #{signal.id} failed after #{state.max_retries} retries: #{inspect(reason)}")
      {:cont, state}
    end
  end

  def after_dispatch(_signal, _subscriber, :ok, _context, state) do
    {:cont, state}
  end

  defp schedule_retry(signal, subscriber, reason) do
    # Implementation depends on your needs
    # Could use Process.send_after, a job queue, etc.
  end
end
```

## Performance Considerations

- Middleware are executed synchronously in the order they're configured
- Keep middleware operations fast to avoid blocking signal processing
- Use `after_*` callbacks for side effects that don't need to modify signals
- Consider the impact of middleware on signal throughput in high-volume scenarios

## Testing Middleware

```elixir
defmodule MyApp.AuditMiddlewareTest do
  use ExUnit.Case
  alias MyApp.AuditMiddleware

  test "logs signals to audit table" do
    # Create audit table
    :ets.new(:test_audit, [:named_table, :public])
    
    # Initialize middleware
    {:ok, state} = AuditMiddleware.init(audit_table: :test_audit)
    
    # Create test signal and context
    signal = %Jido.Signal{id: "test-1", type: "test.signal", source: "/test"}
    context = %{bus_name: :test, timestamp: DateTime.utc_now(), metadata: %{}}
    
    # Execute middleware
    {:cont, _signals, _state} = AuditMiddleware.before_publish([signal], context, state)
    
    # Verify audit entry was created
    assert [{"test-1", "test.signal", _, _}] = :ets.lookup(:test_audit, "test-1")
    
    # Cleanup
    :ets.delete(:test_audit)
  end
end
```

This middleware system provides powerful extensibility while maintaining clean separation of concerns and testability.